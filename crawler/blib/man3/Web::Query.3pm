.\" Automatically generated by Pod::Man 2.28 (Pod::Simple 3.29)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Web::Query 3"
.TH Web::Query 3 "2016-07-03" "perl v5.22.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Web::Query \- Yet another scraping library like jQuery
.SH "VERSION"
.IX Header "VERSION"
version 0.38
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Web::Query;
\&
\&    wq(\*(Aqhttp://www.w3.org/TR/html401/\*(Aq)
\&        \->find(\*(Aqdiv.head dt\*(Aq)
\&        \->each(sub {
\&            my $i = shift;
\&            printf("%d %s\en", $i+1, $_\->text);
\&        });
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Web::Query is a yet another scraping framework, have a jQuery like interface.
.PP
Yes, I know Ingy's pQuery. But it's just a alpha quality. It doesn't works.
Web::Query built at top of the \s-1CPAN\s0 modules, HTML::TreeBuilder::XPath, LWP::UserAgent, and HTML::Selector::XPath.
.PP
So, this module uses HTML::Selector::XPath and only supports the \s-1CSS 3\s0
selector supported by that module.
Web::Query doesn't support jQuery's extended queries(yet?). If a selector is 
passed as a scalar ref, it'll be taken as a straight XPath expression.
.PP
.Vb 2
\&    $wq( \*(Aq<div><p>hello</p><p>there</p></div>\*(Aq )\->find( \*(Aqp\*(Aq );       # css selector
\&    $wq( \*(Aq<div><p>hello</p><p>there</p></div>\*(Aq )\->find( \e\*(Aq/div/p\*(Aq ); # xpath selector
.Ve
.PP
\&\fB\s-1THIS LIBRARY IS UNDER DEVELOPMENT. ANY API MAY CHANGE WITHOUT NOTICE\s0\fR.
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
.ie n .IP """wq($stuff)""" 4
.el .IP "\f(CWwq($stuff)\fR" 4
.IX Item "wq($stuff)"
This is a shortcut for \f(CW\*(C`Web::Query\->new($stuff)\*(C'\fR. This function is exported by default.
.SH "METHODS"
.IX Header "METHODS"
.SS "\s-1CONSTRUCTORS\s0"
.IX Subsection "CONSTRUCTORS"
.ie n .IP "my $q = Web::Query\->new($stuff, \e%options )" 4
.el .IP "my \f(CW$q\fR = Web::Query\->new($stuff, \e%options )" 4
.IX Item "my $q = Web::Query->new($stuff, %options )"
Create new instance of Web::Query. You can make the instance from \s-1URL\s0(http, https, file scheme), \s-1HTML\s0 in string, \s-1URL\s0 in string, \s-1URI\s0 object, \f(CW\*(C`undef\*(C'\fR, and either one 
HTML::Element object or an array ref of them.
.Sp
.Vb 4
\&    # all valid creators
\&    $q = Web::Query\->new( \*(Aqhttp://techblog.babyl.ca\*(Aq );
\&    $q = Web::Query\->new( \*(Aq<p>foo</p>\*(Aq );
\&    $q = Web::Query\->new( undef );
.Ve
.Sp
This method throw the exception on unknown \f(CW$stuff\fR.
.Sp
This method returns undefined value on non-successful response with \s-1URL.\s0
.Sp
Currently, the only two valid options are \fIindent\fR, which will be used as
the indentation string if the object is printed, and \fIno_space_compacting\fR, 
which will prevent the compaction of whitespace characters in text blocks.
.ie n .IP "my $q = Web::Query\->new_from_element($element: HTML::Element)" 4
.el .IP "my \f(CW$q\fR = Web::Query\->new_from_element($element: HTML::Element)" 4
.IX Item "my $q = Web::Query->new_from_element($element: HTML::Element)"
Create new instance of Web::Query from instance of HTML::Element.
.ie n .IP """my $q = Web::Query\->new_from_html($html: Str)""" 4
.el .IP "\f(CWmy $q = Web::Query\->new_from_html($html: Str)\fR" 4
.IX Item "my $q = Web::Query->new_from_html($html: Str)"
Create new instance of Web::Query from \s-1HTML.\s0
.ie n .IP "my $q = Web::Query\->new_from_url($url: Str)" 4
.el .IP "my \f(CW$q\fR = Web::Query\->new_from_url($url: Str)" 4
.IX Item "my $q = Web::Query->new_from_url($url: Str)"
Create new instance of Web::Query from \s-1URL.\s0
.Sp
If the response is not success(It means /^20[0\-9]$/), this method returns undefined value.
.Sp
You can get a last result of response, use the \f(CW$Web::Query::RESPONSE\fR.
.Sp
Here is a best practical code:
.Sp
.Vb 3
\&    my $url = \*(Aqhttp://example.com/\*(Aq;
\&    my $q = Web::Query\->new_from_url($url)
\&        or die "Cannot get a resource from $url: " . Web::Query\->last_response()\->status_line;
.Ve
.ie n .IP "my $q = Web::Query\->new_from_file($file_name: Str)" 4
.el .IP "my \f(CW$q\fR = Web::Query\->new_from_file($file_name: Str)" 4
.IX Item "my $q = Web::Query->new_from_file($file_name: Str)"
Create new instance of Web::Query from file name.
.SS "\s-1TRAVERSING\s0"
.IX Subsection "TRAVERSING"
\fIadd\fR
.IX Subsection "add"
.PP
Returns a new object augmented with the new element(s).
.IP "add($html)" 4
.IX Item "add($html)"
An \s-1HTML\s0 fragment to add to the set of matched elements.
.IP "add(@elements)" 4
.IX Item "add(@elements)"
One or more \f(CW@elements\fR to add to the set of matched elements.
.Sp
\&\f(CW@elements\fR that already are part of the set are not added a second time.
.Sp
.Vb 3
\&    my $group = $wq\->find(\*(Aq#foo\*(Aq);         # collection has 1 element
\&    $group = $group\->add( \*(Aq#bar\*(Aq, $wq );   # 2 elements
\&    $group\->add( \*(Aq#foo\*(Aq, $wq );            # still 2 elements
.Ve
.IP "add($wq)" 4
.IX Item "add($wq)"
An existing Web::Query object to add to the set of matched elements.
.ie n .IP "add($selector, $context)" 4
.el .IP "add($selector, \f(CW$context\fR)" 4
.IX Item "add($selector, $context)"
\&\f(CW$selector\fR is a string representing a selector expression to find additional elements to add to the set of matched elements.
.Sp
\&\f(CW$context\fR is the point in the document at which the selector should begin matching
.PP
\fIcontents\fR
.IX Subsection "contents"
.PP
Get the immediate children of each element in the set of matched elements, including text and comment nodes.
.PP
\fIeach\fR
.IX Subsection "each"
.PP
Visit each nodes. \f(CW$i\fR is a counter value, 0 origin. \f(CW$elem\fR is iteration item.
\&\f(CW$_\fR is localized by \f(CW$elem\fR.
.PP
.Vb 1
\&    $q\->each(sub { my ($i, $elem) = @_; ... })
.Ve
.PP
\fIend\fR
.IX Subsection "end"
.PP
Back to the before context like jQuery.
.PP
\fIfilter\fR
.IX Subsection "filter"
.PP
Reduce the elements to those that pass the function's test.
.PP
.Vb 1
\&    $q\->filter(sub { my ($i, $elem) = @_; ... })
.Ve
.PP
\fIfind\fR
.IX Subsection "find"
.PP
Get the descendants of each element in the current set of matched elements, filtered by a selector.
.PP
.Vb 1
\&    my $q2 = $q\->find($selector); # $selector is a CSS3 selector.
.Ve
.PP
\&\fB\s-1NOTE\s0\fR If you want to match the element itself, use \*(L"filter\*(R".
.PP
\&\fB\s-1INCOMPATIBLE CHANGE\s0\fR 
From v0.14 to v0.19 (inclusive) \fIfind()\fR also matched the element itself, which is not jQuery compatible.
You can achieve that result using \f(CW\*(C`filter()\*(C'\fR, \f(CW\*(C`add()\*(C'\fR and \f(CW\*(C`find()\*(C'\fR:
.PP
.Vb 2
\&    my $wq = wq(\*(Aq<div class="foo"><p class="foo">bar</p></div>\*(Aq); # needed because we don\*(Aqt have a global document like jQuery does
\&    print $wq\->filter(\*(Aq.foo\*(Aq)\->add($wq\->find(\*(Aq.foo\*(Aq))\->as_html; # <div class="foo"><p class="foo">bar</p></div><p class="foo">bar</p>
.Ve
.PP
\fIfirst\fR
.IX Subsection "first"
.PP
Return the first matching element.
.PP
This method constructs a new Web::Query object from the first matching element.
.PP
\fIlast\fR
.IX Subsection "last"
.PP
Return the last matching element.
.PP
This method constructs a new Web::Query object from the last matching element.
.PP
\fImatch($selector)\fR
.IX Subsection "match($selector)"
.PP
Returns a boolean indicating if the elements match the \f(CW$selector\fR.
.PP
In scalar context returns only the boolean for the first element.
.PP
For the reverse of \f(CW\*(C`not()\*(C'\fR, see \f(CW\*(C`filter()\*(C'\fR.
.PP
\fInot($selector)\fR
.IX Subsection "not($selector)"
.PP
Returns all the elements not matching the \f(CW$selector\fR.
.PP
.Vb 2
\&    # $do_for_love will be every thing, except #that
\&    my $do_for_love = $wq\->find(\*(Aqthing\*(Aq)\->not(\*(Aq#that\*(Aq);
.Ve
.PP
\fIand_back\fR
.IX Subsection "and_back"
.PP
Add the previous set of elements to the current one.
.PP
.Vb 2
\&    # get the h1 plus everything until the next h1
\&    $wq\->find(\*(Aqh1\*(Aq)\->next_until(\*(Aqh1\*(Aq)\->and_back;
.Ve
.PP
\fImap\fR
.IX Subsection "map"
.PP
Creates a new array with the results of calling a provided function on every element.
.PP
.Vb 1
\&    $q\->map(sub { my ($i, $elem) = @_; ... })
.Ve
.PP
\fIparent\fR
.IX Subsection "parent"
.PP
Get the parent of each element in the current set of matched elements.
.PP
\fIprev\fR
.IX Subsection "prev"
.PP
Get the previous node of each element in the current set of matched elements.
.PP
.Vb 1
\&    my $prev = $q\->prev;
.Ve
.PP
\fInext\fR
.IX Subsection "next"
.PP
Get the next node of each element in the current set of matched elements.
.PP
.Vb 1
\&   my $next = $q\->next;
.Ve
.PP
\fInext_until( \f(CI$selector\fI )\fR
.IX Subsection "next_until( $selector )"
.PP
Get all subsequent siblings, up to (but not including) the next node matched \f(CW$selector\fR.
.SS "\s-1MANIPULATION\s0"
.IX Subsection "MANIPULATION"
\fIadd_class\fR
.IX Subsection "add_class"
.PP
Adds the specified class(es) to each of the set of matched elements.
.PP
.Vb 2
\&    # add class \*(Aqfoo\*(Aq to <p> elements
\&    wq(\*(Aq<div><p>foo</p><p>bar</p></div>\*(Aq)\->find(\*(Aqp\*(Aq)\->add_class(\*(Aqfoo\*(Aq);
.Ve
.PP
\fItoggle_class( \f(CI@classes\fI )\fR
.IX Subsection "toggle_class( @classes )"
.PP
Toggles the given class or classes on each of the element. I.e., if the element had the class, it'll be removed,
and if it hadn't, it'll be added.
.PP
Classes are toggled once, no matter how many times they appear in the argument list.
.PP
.Vb 1
\&    $q\->toggle_class( \*(Aqfoo\*(Aq, \*(Aqfoo\*(Aq, \*(Aqbar\*(Aq );
\&
\&    # equivalent to
\&    
\&    $q\->toggle_class(\*(Aqfoo\*(Aq)\->toggle_class(\*(Aqbar\*(Aq);
\&
\&    # and not
\&
\&    $q\->toggle_class(\*(Aqfoo\*(Aq)\->toggle_class(\*(Aqfoo\*(Aq)\->toggle_class(\*(Aqbar\*(Aq);
.Ve
.PP
\fIafter\fR
.IX Subsection "after"
.PP
Insert content, specified by the parameter, after each element in the set of matched elements.
.PP
.Vb 4
\&    wq(\*(Aq<div><p>foo</p></div>\*(Aq)\->find(\*(Aqp\*(Aq)
\&                               \->after(\*(Aq<b>bar</b>\*(Aq)
\&                               \->end
\&                               \->as_html; # <div><p>foo</p><b>bar</b></div>
.Ve
.PP
The content can be anything accepted by \*(L"new\*(R".
.PP
\fIappend\fR
.IX Subsection "append"
.PP
Insert content, specified by the parameter, to the end of each element in the set of matched elements.
.PP
.Vb 1
\&    wq(\*(Aq<div></div>\*(Aq)\->append(\*(Aq<p>foo</p>\*(Aq)\->as_html; # <div><p>foo</p></div>
.Ve
.PP
The content can be anything accepted by \*(L"new\*(R".
.PP
\fIas_html\fR
.IX Subsection "as_html"
.PP
Returns the string representations of either the first or all elements,
depending if called in list or scalar context.
.PP
If given an argument \f(CW\*(C`join\*(C'\fR, the string representations of the elements
will be concatenated with the given string.
.PP
.Vb 4
\&    wq( \*(Aq<div><p>foo</p><p>bar</p></div>\*(Aq )
\&        \->find(\*(Aqp\*(Aq)
\&        \->as_html( join => \*(Aq!\*(Aq );
\&    # <p>foo</p>!<p>bar</p>
.Ve
.PP
\fI\f(CI\*(C` attr \*(C'\fI\fR
.IX Subsection " attr "
.PP
Get/set attribute values.
.PP
In getter mode, it'll return either the values of the attribute
for all elements of the set, or only the first one depending of the calling context.
.PP
.Vb 2
\&    my @values = $q\->attr(\*(Aqstyle\*(Aq);      # style of all elements
\&    my $first_value = $q\->attr(\*(Aqstyle\*(Aq); # style of first element
.Ve
.PP
In setter mode, it'll set attributes value for all elements, and return back
the original object for easy chaining.
.PP
.Vb 1
\&    $q\->attr( \*(Aqalt\*(Aq => \*(Aqa picture\*(Aq )\->find( ... );
\&
\&    # can pass more than 1 element too
\&    $q\->attr( alt => \*(Aqa picture\*(Aq, src => \*(Aqfile:///...\*(Aq );
.Ve
.PP
The value passed for an attribute can be a code ref. In that case,
the code will be called with \f(CW$_\fR set to the current attribute value.
If the code modifies \f(CW$_\fR, the attribute will be updated with the new value.
.PP
.Vb 1
\&    $q\->attr( alt => sub { $_ ||= \*(AqA picture\*(Aq } );
.Ve
.PP
\fI\f(CI\*(C` id \*(C'\fI\fR
.IX Subsection " id "
.PP
Get/set the elements's id attribute.
.PP
In getter mode, it behaves just like \f(CW\*(C`attr()\*(C'\fR.
.PP
In setter mode, it behaves like \f(CW\*(C`attr()\*(C'\fR, but with the following exceptions.
.PP
If the attribute value is a scalar, it'll be only assigned to
the first element of the set (as ids are supposed to be unique), and the returned object will only contain
that first element.
.PP
.Vb 1
\&    my $first_element = $q\->id(\*(Aqthe_one\*(Aq);
.Ve
.PP
It's possible to set the ids of all the elements by passing a sub to \f(CW\*(C`id()\*(C'\fR. The sub is given the same arguments as for
\&\f(CW\*(C`each()\*(C'\fR, and its return value is taken to be the new id of the elements.
.PP
.Vb 1
\&    $q\->id( sub { my $i = shift;  \*(Aqfoo_\*(Aq . $i } );
.Ve
.PP
\fI\f(CI\*(C` name \*(C'\fI\fR
.IX Subsection " name "
.PP
Get/set the elements's 'name' attribute.
.PP
.Vb 1
\&    my $name = $q\->name;  # equivalent to $q\->attr( \*(Aqname\*(Aq );
\&
\&    $q\->name( \*(Aqfoo\*(Aq );    # equivalent to $q\->attr( name => \*(Aqfoo\*(Aq );
.Ve
.PP
\fI\f(CI\*(C` data \*(C'\fI\fR
.IX Subsection " data "
.PP
Get/set the elements's 'data\-*name*' attributes.
.PP
.Vb 1
\&    my $data = $q\->data(\*(Aqfoo\*(Aq);  # equivalent to $q\->attr( \*(Aqdata\-foo\*(Aq );
\&
\&    $q\->data( \*(Aqfoo\*(Aq => \*(Aqbar\*(Aq );  # equivalent to $q\->attr( \*(Aqdata\-foo\*(Aq => \*(Aqbar\*(Aq );
.Ve
.PP
\fItagname\fR
.IX Subsection "tagname"
.PP
Get/Set the tag name of elements.
.PP
.Vb 1
\&    my $name = $q\->tagname;
\&
\&    $q\->tagname($new_name);
.Ve
.PP
\fIbefore\fR
.IX Subsection "before"
.PP
Insert content, specified by the parameter, before each element in the set of matched elements.
.PP
.Vb 4
\&    wq(\*(Aq<div><p>foo</p></div>\*(Aq)\->find(\*(Aqp\*(Aq)
\&                               \->before(\*(Aq<b>bar</b>\*(Aq)
\&                               \->end
\&                               \->as_html; # <div><b>bar</b><p>foo</p></div>
.Ve
.PP
The content can be anything accepted by \*(L"new\*(R".
.PP
\fIclone\fR
.IX Subsection "clone"
.PP
Create a deep copy of the set of matched elements.
.PP
\fIdetach\fR
.IX Subsection "detach"
.PP
Remove the set of matched elements from the \s-1DOM.\s0
.PP
\fIhas_class\fR
.IX Subsection "has_class"
.PP
Determine whether any of the matched elements are assigned the given class.
.PP
\fI\f(CI\*(C` html \*(C'\fI\fR
.IX Subsection " html "
.PP
Get/Set the innerHTML.
.PP
.Vb 1
\&    my @html = $q\->html();
\&
\&    my $html = $q\->html(); # 1st matching element only
\&
\&    $q\->html(\*(Aq<p>foo</p>\*(Aq);
.Ve
.PP
\fIinsert_before\fR
.IX Subsection "insert_before"
.PP
Insert every element in the set of matched elements before the target.
.PP
\fIinsert_after\fR
.IX Subsection "insert_after"
.PP
Insert every element in the set of matched elements after the target.
.PP
\fI\f(CI\*(C` prepend \*(C'\fI\fR
.IX Subsection " prepend "
.PP
Insert content, specified by the parameter, to the beginning of each element in the set of matched elements.
.PP
\fIremove\fR
.IX Subsection "remove"
.PP
Delete the elements associated with the object from the \s-1DOM.\s0
.PP
.Vb 2
\&    # remove all <blink> tags from the document
\&    $q\->find(\*(Aqblink\*(Aq)\->remove;
.Ve
.PP
\fIremove_class\fR
.IX Subsection "remove_class"
.PP
Remove a single class, multiple classes, or all classes from each element in the set of matched elements.
.PP
\fIreplace_with\fR
.IX Subsection "replace_with"
.PP
Replace the elements of the object with the provided replacement. 
The replacement can be a string, a \f(CW\*(C`Web::Query\*(C'\fR object or an 
anonymous function. The anonymous function is passed the index of the current 
node and the node itself (with is also localized as \f(CW$_\fR).
.PP
.Vb 1
\&    my $q = wq( \*(Aq<p><b>Abra</b><i>cada</i><u>bra</u></p>\*(Aq );
\&
\&    $q\->find(\*(Aqb\*(Aq)\->replace_with(\*(Aq<a>Ocus</a>);
\&        # <p><a>Ocus</a><i>cada</i><u>bra</u></p>
\&
\&    $q\->find(\*(Aqu\*(Aq)\->replace_with($q\->find(\*(Aqb\*(Aq));
\&        # <p><i>cada</i><b>Abra</b></p>
\&
\&    $q\->find(\*(Aqi\*(Aq)\->replace_with(sub{ 
\&        my $name = $_\->text;
\&        return "<$name></$name>";
\&    });
\&        # <p><b>Abra</b><cada></cada><u>bra</u></p>
.Ve
.PP
\fIsize\fR
.IX Subsection "size"
.PP
Return the number of elements in the Web::Query object.
.PP
.Vb 1
\&    wq(\*(Aq<div><p>foo</p><p>bar</p></div>\*(Aq)\->find(\*(Aqp\*(Aq)\->size; # 2
.Ve
.PP
\fItext\fR
.IX Subsection "text"
.PP
Get/Set the text.
.PP
.Vb 1
\&    my @text = $q\->text();
\&
\&    my $text = $q\->text(); # 1st matching element only
\&
\&    $q\->text(\*(Aqtext\*(Aq);
.Ve
.PP
If called in a scalar context, only return the string representation
of the first element
.SS "\s-1OTHERS\s0"
.IX Subsection "OTHERS"
.IP "Web::Query\->\fIlast_response()\fR" 4
.IX Item "Web::Query->last_response()"
Returns last \s-1HTTP\s0 response status that generated by \f(CW\*(C`new_from_url()\*(C'\fR.
.SH "HOW DO I CUSTOMIZE USER AGENT?"
.IX Header "HOW DO I CUSTOMIZE USER AGENT?"
You can specify your own instance of LWP::UserAgent.
.PP
.Vb 1
\&    $Web::Query::UserAgent = LWP::UserAgent\->new( agent => \*(AqMozilla/5.0\*(Aq );
.Ve
.SH "FAQ AND TROUBLESHOOTING"
.IX Header "FAQ AND TROUBLESHOOTING"
.SS "How to find \s-1XML\s0 processing instructions in a document?"
.IX Subsection "How to find XML processing instructions in a document?"
It's possible with Web::Query::LibXML and by using an xpath expression
with \f(CW\*(C`find()\*(C'\fR:
.PP
.Vb 2
\&    # find <?xml\-stylesheet ... ?>
\&    $q\->find(\e"//processing\-instruction(\*(Aqxml\-stylesheet\*(Aq)");
.Ve
.PP
However, note that the support for processing instructions 
in HTML::TreeBuilder::LibXML::Node is sketchy, so there
are methods like \f(CW\*(C`attr()\*(C'\fR that won't work.
.SS "Can't get the content of script elements"
.IX Subsection "Can't get the content of script elements"
The <script> tag is treated differently by HTML::TreeBuilder, the 
parser used by Web::Query. To retrieve the content, you can use either
the method \f(CW\*(C`html()\*(C'\fR (with the caveat that the content will be escaped),
or use Web::Query::LibXML, which parse the 'script' element differently.
.PP
.Vb 1
\&    my $node = "<script>var x = \*(Aq<p>foo</p>\*(Aq;</script>";
\&
\&    say Web::Query::wq( $node )\->text;  
\&        # nothing is printed!
\&        
\&    say Web::Query::wq( $node )\->html;  
\&        # var x = &#39;&lt;p&gt;foo&lt;/p&gt;&#39;;
\&
\&    say Web::Query::LibXML::wq( $node )\->text;
\&        # var x = \*(Aq<p>foo</p>\*(Aq;
\&        
\&    say Web::Query::LibXML::wq( $node )\->html;
\&        # var x = \*(Aq&lt;p&gt;foo&lt;/p&gt;\*(Aq;
.Ve
.SH "INCOMPATIBLE CHANGES"
.IX Header "INCOMPATIBLE CHANGES"
.IP "0.10" 4
.IX Item "0.10"
\&\fInew_from_url()\fR is no longer throws exception on bad response from \s-1HTTP\s0 server.
.SH "AUTHOR"
.IX Header "AUTHOR"
Tokuhiro Matsuno <tokuhirom AAJKLFJEF@ \s-1GMAIL COM\s0>
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "pQuery" 4
.IX Item "pQuery"
.PD 0
.IP "XML::LibXML::jQuery" 4
.IX Item "XML::LibXML::jQuery"
.PD
.SH "LICENSE"
.IX Header "LICENSE"
Copyright (C) Tokuhiro Matsuno
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
.SH "BUGS"
.IX Header "BUGS"
Please report any bugs or feature requests on the bugtracker website
https://github.com/tokuhirom/Web\-Query/issues
.PP
When submitting a bug or request, please include a test-file or a
patch to an existing test-file that illustrates the bug or desired
feature.
